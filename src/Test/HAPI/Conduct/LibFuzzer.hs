module Test.HAPI.Conduct.LibFuzzer where

import Test.HAPI.AASTG.Core ( AASTG )
import qualified Data.ByteString as BS
import Foreign.C (CString, CSize, CInt)
import Test.HAPI.Run (runFuzzTest, runFuzzTrace)
import Test.HAPI.Api (ValidApiDef)
import Test.HAPI.Common ( Fuzzable )
import Options.Applicative (Parser, strArgument, help, info, (<**>), helper, fullDesc, progDesc, header, execParser, metavar)

data LibFuzzerConduct = LibFuzzerConduct
  { llvmFuzzerTestOneInputM :: CString -> CSize -> IO CInt
  , mainM                   :: IO ()
  }


libFuzzerConductViaAASTG :: (ValidApiDef api) => AASTG api Fuzzable -> LibFuzzerConduct
libFuzzerConductViaAASTG aastg = LibFuzzerConduct
  { llvmFuzzerTestOneInputM = _llvmFuzzerTestOneInputM aastg
  , mainM                   = _traceMainM aastg
  }

_llvmFuzzerTestOneInputM :: (ValidApiDef api) => AASTG api Fuzzable -> CString -> CSize -> IO CInt
_llvmFuzzerTestOneInputM aastg str size = do
  bs <- BS.packCStringLen (str, fromIntegral size)
  runFuzzTest aastg bs
  return 0

_traceMainM :: (ValidApiDef api) => AASTG api Fuzzable -> IO ()
_traceMainM aastg = do
  opt <- execParser opts
  let path = crashPath opt
  bs <- BS.readFile path
  runFuzzTrace aastg bs
  where
    opts = info (traceOpt <**> helper)
      (  fullDesc
      <> progDesc "Read crash file generated by LibFuzzer, and generate code"
      <> header   "HAPI LibFuzzer Tracer" )

newtype TraceOpt = TraceOpt {crashPath :: FilePath}

traceOpt :: Parser TraceOpt
traceOpt = TraceOpt
  <$> strArgument (metavar "PATH" <> help "LibFuzzer generated crash file location")
